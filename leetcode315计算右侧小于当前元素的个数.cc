/*
给定一个整数数组nums,按照要求返回一个新数组counts。数组counts有该性质，counts[i]
的值是Nums[i]右侧小于Nums[i]的元素的数量。

看一种数据结构——树状数组 https://www.cnblogs.com/xenny/p/9739600.html
树状数组有什么特性？
优点是什么？

    可以解决大部分区间上的更新以及求和问题。
    树状数组查询和修改的复杂度都是Olong(n),比线性数组要小得多。
    解决数组间查询问题。 

    又叫二叉索引数组， 解决数组区间查询问题

    需求：
    老板给你分了台2Ghz单核，内存500M的服务器然后让你写程序
    程序每秒会收到一组数据，每组数据包含10万条命令，总共会有100万个仓库
    每个仓库库存没有上限其可为负，库存初始为0，你需要在一秒内 完成全部的命令
    然后将查询结果按照顺序得出后传回。 命令如下：
    Add i,j  i和j为正整数，表示第i个仓库增加j个库存(j不超过2^20)
    Sub i j  i和j为正整数，表示第i个仓库减少j个库存
    Query i j i和j为正整数， i<=j,表示询问第i和第j个仓库的总库存
    End表示结束，这条命令在每组数据最后出现


    每个数都有一个二进制表示，即所有数都可以表示成x个不同的2的幂之和

    dp是存储了全部位置的和
    而树状数组存储了部分位置的和

    最后的数据结构会有什么呢？
    
    x的补码 = x的非码 + 1

    什么是lowbit运算？
        假设计算机中有一个数，叫做x,它的lowbit就是其二进制格式中最后一个为1以及其后为0的那个范围的数
        lowbit位如何计算？
        可以先求其反码，即按位取反， ~x, 再加1

        之后再和x进行按位与，即可得到lowbit数
        int lowbit = (~x+1)&x；
        (~x+1)&x 等于 x&-x

        得到每个index的lowBit之后，就可以建立树状数组了
        树状数组t[x]保存以x为根的自述中叶子节点值的和
        
        原来的数组是 a[1] a[2] a[3] a[4]

        把每个节点的t[x]中的x转化为二进制后，会发现每一层的末尾的0的个数都是相同的
        0的个数和其覆盖的长度有关，
        进一步观察，t[x]节点覆盖的长度就是 lowbit(x)

        比如二进制1是1，那么就覆盖1个a[x]
        二进制10是2,那么就覆盖2个a[x]
        二进制100是4
        t[x]节点的父节点为t[x+lowbit(x)]
        整棵树的深度为logn+1
        
        一个树状数组节点的值，等于其左侧所覆盖的所有节点之和
        比如 t[8] = t[7]+t[6]+t[4]
        
        如何求出一个节点的父节点？
        t[x]和a[i]的关系是如何的呢？
        
        

        对于add操作的实现
        树状数组是动态维护前缀和工具以及区间修改，区间查询

        
*/